var documenterSearchIndex = {"docs":
[{"location":"Elasticity2DAFW/#Planar-Elasticity-(Work-in-Progress)","page":"Planar Elasticity (Work in Progress)","title":"Planar Elasticity (Work in Progress)","text":"","category":"section"},{"location":"Elasticity2DAFW/#Description","page":"Planar Elasticity (Work in Progress)","title":"Description","text":"This benchmark is the planar elastodynamic problem presented in [6] and discretized using the Arnold-Falk-Whinter weakly symmetric element [7].  It corresponds to a mixed Hamiltonian formulation of linearized elasticity. Let Omega subseteq mathbbR^2 be a Lipschitz domain and mathbbT = 0T for T in (0infty). Consider the system of coupled partial differential equations\n\nbeginaligned\n rho fracpartialpartial t bmv(txi) = mathrmdiv bmSigma quad textin  (0T times Omega  \n mathcalCfracpartialpartial t bmSigma = mathrmsymnabla bmv quad textin  (0T times Omega\nendaligned\n\nThe operators appearing in this formulation are the symmetric gradient mathrmsymnabla = frac12(nabla + nabla^top) and the row-wise tensor divergence (mathrmDiv bmSigma)_i = sum_j partial_j bmSigma_ij. The velocity field bmv mathbbT times Omega to R^2 and the symmetric stress tensor field bmSigma mathbbT times Omega to R^2times 2_textsym are the unknowns of the problem. The physical parameters are the density rho and\n\nmathcalC= frac12muleft(cdot) - fraclambda2mu + 2lambda mathrmTr(cdot) mathbfIright\n\nthe isotropic compliance tensor, where mu and lambda are the Lamé coefficients and mathbfI is the identity in R^2. \n\nThe system can be compactly rewritten as\n\nmathcalEpartial_t bmx = mathcalJbmx quad textin  (0T times Omega\n\nwhere mathcalE is a bounded, symmetric and uniformly positive operator and mathcalJ is a formally skew-adjoint operator.\n\nThe PDE is boundary controlled via the Dirichlet boundary condition\n\n bmv(txi) = u_D(t xi) quad texton (0T times partial Omega\n\nas well initial conditions bmv(0cdot) = bmv^0  partial Omega to R^2, bmSigma(0cdot) = bmSigma^0  partial Omega to R^d times d_mathrmsym.  The construction of conforming finite elements for symmetric tensors is involved. Therefore, a weakly symmetric finite element formulation will be employed, based on the following decomposition of the symmetric gradient \n\n mathrmsymnabla bmv = nabla bmv - mathrmskw(nabla bmv)\n\nwhere skw bmA = (bmA - bmA^top)2 in R^2times 2_mathrmskw is the skew-symmetric part of a matrix.  To introduce the weak form, define the Hilbert spaces\n\nbeginaligned\nV = L^2(Omega R^2) \nM = H^mathrmdiv(Omega R^2 times 2) = bmA in L^2(Omega R^2times 2)   mathrmdivbmA in L^2(Omega R^2) \nK = L^2(Omega R^2times 2_mathrmskw) \nU = H^12(partialOmega R^2)\nendaligned\n\nTo determine the weak form of the PDE, the first equation is  multiplied by a test function bmpsi_v in V. The second equation is multiplied by bmPsi_Sigma in M and integrated by parts. A third equation imposes the symmetry weakly by taking the inner product between a skew-symmetric test function and the stress tensor. The weak formulation therefore reads: given the initial conditions and the input bmu_D in U find bmv in V  bmSigma in M  bmR in K such that\n\nbeginaligned\nint_Omega bmpsi_v cdot partial_t bmv dx = int_Omega bmpsi_v cdot mathrmDiv bmSigma dx qquad forall bmpsi_v in mathcalV \nint_Omega bmPsi_Sigma  partial_t bmSigma dx + int_Omega bmPsi_Sigma  partial_t bmR dx = -int_Omega mathrmDiv bmpsi_Sigma cdot bmv dx + leftlanglebmpsi_Sigma cdot bmn  bmu_Drightrangle qquad forall bmpsi_v in mathcalV \nint_Omega bmPsi_R  partial_t bmSigma qquad forall bmPsi_R in mathcalK\nendaligned\n\nwhere bmA = bmB = sumlimits_ij bmA_ij bmB_ij denotes the tensor contraction and leftlangle cdot  cdot rightrangle denotes a duality pairing between mathcalU and its topological dual mathcalU = H^-12(partialOmega R^2).  Consider a regular triangulation mathcalT_h with elements T. At the boundary partialOmega, the triangulation gives rise to boundary edges mathcalE_h^partial with edges E^partial. The following conforming finite element spaces are used to discretize the weak formulation \n\nbeginaligned\nV_h = bmv_h in L^2(Omega R^2)   forall T in mathcalT_h bmv_h_T in mathrmDG_k-1^2 \nM_h = bmSigma_h in H^mathrmdiv(Omega R^2 times 2)   forall T in mathcalT_h  text and for  i=12 (bmSigma_i1 h  bmSigma_j2 h)_T in mathrmBDM_k \nK_h = bmR_h in L^2(Omega R^2times 2_mathrmskw)   forall T in mathcalT_h bmR_h_T in mathrmDG_k-1 \nU_h = u_D h in H^12(partialOmega R^2)   forall E^partial in mathcalE_h^partial bmu_D h_E^partial in mathrmCG_k \nendaligned\n\nwhere k ge 1 is the polynomial degree of the finite elements and the acronyms stand for\n\nDG: the discontinous galerkin finite element space;\nBDM: the Brezzi-Douglas-Marini space;\nCG: Lagrange elements.\n\nInserting the finite element approximation into the weak formulation, the following port-Hamiltonian system is obtained\n\nbeginaligned\n mathbfE dotmathbfx(t) = mathbfJmathbfx(t) + mathbfB mathbfu_D(t) \n  mathrmy(t) = mathbfB^mathsfT mathbfx(t)\nendaligned\n\nwith \n\nbeginaligned\n mathbfE = beginbmatrix\n mathbfM_rho  0  0  0  mathbfM_mathcalC  mathbfA_lambda^mathsfT  0  mathbfA_lambda  0\n endbmatrix quad\n  mathbfJ = beginbmatrix\n 0  mathbfD_mathrmdiv  0  - mathbfD_mathrmdiv^mathsfT  0  0   0  0  0\n endbmatrix quad\n mathbfB = beginbmatrix 0  mathbfB_D  0 endbmatrix\nendaligned","category":"section"},{"location":"Elasticity2DAFW/#Parameters","page":"Planar Elasticity (Work in Progress)","title":"Parameters","text":"For this benchmark, a square domain Omega = 01^2 is considered. Moreover, different discretization levels are available,   resulting in systems with state-space dimensions n=1260 (5 elements per side and k=2), n = 1880 (10 elements per side and k=1), and n = 4920 (10 elements per side and k=2). These discretizations have been obtained using the python  interface of FEniCS. The following fixed parameters have been chosen:\n\nlambda = 20,\nmu = 4\nrho = 1,","category":"section"},{"location":"Elasticity2DAFW/#Interface","page":"Planar Elasticity (Work in Progress)","title":"Interface","text":"The system matrices E J R and B can be generated by the following function call.\n\nusing PortHamiltonianBenchmarkSystems\nE, J, B = elasticity2Dafw_model()\n\nThe free parameters are given as named arguments. Note that n in  1260 1880 4920 .\n\nusing PortHamiltonianBenchmarkSystems\nE, J, R, B = elasticity2Dafw_model(n = 1260)\nH(s) = B'*((s*E-(J-R))\\B)\n\nHere H is the transfer function.","category":"section"},{"location":"Elasticity2DAFW/#References","page":"Planar Elasticity (Work in Progress)","title":"References","text":"A. Brugnoli. A port-Hamiltonian formulation of flexible structures. Modelling and structure-preserving finite element discretization. Ph.D. Thesis, Université de Toulouse, ISAE-SUPAERO, France (2020).\n\n\n\nD. N. Arnold and J. J. Lee. Mixed Methods for Elastodynamics with Weak Symmetry. SIAM Journal on Numerical Analysis 52, 2743–2769 (2014).\n\n\n\n","category":"section"},{"location":"Elasticity2DAFW/#PortHamiltonianBenchmarkSystems.Elasticity2DAFWConfig","page":"Planar Elasticity (Work in Progress)","title":"PortHamiltonianBenchmarkSystems.Elasticity2DAFWConfig","text":"This struct configures port Hamiltonian elasticity systems described in     A. Brugnoli: A port-Hamiltonian formulation of flexible structures.     Modelling and structure-preserving finite element discretization\n\nArguments\n\nn: System dimension (can only be either: 1260, 1880, or 4920). Default = 1880.\n\n\n\n\n\n","category":"type"},{"location":"Contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"Contribution/#Modus-Operandi","page":"Contribution","title":"Modus Operandi","text":"This benchmark collection is driven by the active support of the port-Hamiltonian community. If your research has lead to port-Hamiltonian models that may be relevant for this collection, we would be happy to include them. If you wish to contribute to the project directly, please consult this page, fork our Git repository and issue a pull request. Alternatively, feel free to contact us via e-mail to discuss our potential collaboration. We are happy to receive reference implementations in other languages and reimplement them in Julia for this package.\n\nAll entries in the collection consist of code for generating the system matrices, a comprehensive set of tests and a documentation page. Exact instructions for each of these parts are provided in the sections below. Some of the design choices may still be subject to change, but efforts are currently being made to settle on a final structure. Any subsequently required changes to community contributions will be handled by us.","category":"section"},{"location":"Contribution/#Code","page":"Contribution","title":"Code","text":"This package consists of a single module, containing the following five elements:\n\nPHSystem: parametric composite type for storing system matrices in standard port-Hamiltonian form,\n<System>Config: (parametric) composite type for storing parameter sets for some system,\n<System>Config(id::String): external constructor returing default <System>Config instances, based on some id,\nconstruct_system(config::<System>Config): method returning system matrices in \"natural\" form, based on some <System>Config instance,\nPHSystem(config::<System>Config): external constructor returning PHSystem instances, based on some <System>Config instance.\n\nThe last four elements are repeated for each benchmark system and are stored together in /src/<System>.jl, along with their respective docstrings in Markdown format. All <System>.jl files are included in /src/PortHamiltonianBenchmarkSystems.jl.\n\nTo contribute to the code, simply add a file based on the example below at /src/<System>.jl and add a corresponding include statement to /src/PortHamiltonianBenchmarkSystems.jl. Some best practices for more complex systems are also given below.\n\n<details><summary>Code Example</summary><p>\n\nexport RandLinConfig\n\n\"\"\"\nComposite type describing a linear port-Hamiltonian system, where matrices ``J,\\ R,\\ G`` are random dense matrices of the correct structure (R positive semi-definite, J, G skew symmetric) with mean 0 and variance 1.\n# Arguments\n- n_x: number of state variables\n- n_p: number of input and output ports\n\"\"\"\nstruct RandLinConfig\n    n_x::UInt64\n    n_p::UInt64\nend\n\n\"\"\"\nMethod for constructing the system matries in \"natural\" form.\n# Arguments\n- `config`: `RandLinConfig` instance\n# Output\n- `system`: Named tuple containing the system matrices in 'natural' form\n\"\"\"\nfunction construct_system(config::RandLinConfig)\n    M1 = rand(config.n_x, config.n_x)\n    M2 = rand(config.n_x, config.n_x)\n    M3 = rand(config.n_x, config.n_p)\n\n    J = (M1 - M1')/sqrt(2)\n    R = (M2 * M2')/sqrt(config.n_x)\n    G = (M3 - M3')/sqrt(2)\n\n    return (J = J, R = R, G = G)\nend\n\nfunction PHSystem(config::RandLinConfig)\n    J, R, G = construct_system(config)\n\n    E = sparse(1.0I,size(J)...)\n    Q = sparse(1.0I,size(J)...)\n    P = spzeros(size(G)...)\n    N = spzeros(config.n_p, config.n_p)\n    S = spzeros(size(N)...)\n\n    return PHSystem(E, J, R, Q, G, P, S, N)\nend\n\n</details><p>\n\n<details><summary>Best Practices</summary><p>\n\nWhile it may seem unnecessary in a simple case like this, it is important to include an internal constructor in <System>Config, to perform input validation:\n\nstruct RandLinConfig\n    n_x::UInt64\n    n_p::UInt64\n\n    RandLinConfig(n_x::UInt64, n_p::UInt64)\n        @assert n_x > 0 \"Number of state variables must be larger than 0\"\n        @assert n_p > 0 \"Number of ports must be larger than 0\"\n        return new(n_x, n_p)\n    end\nend\n\nSimilarly, while it does not make much sense to save default configurations for this random system, in reality one should provide a few default parameter sets. Once some adequate parameter sets have been determined and implemented in the form shown below, we will store them as MAT-files on our Zenodo and update the code to retrieve them as Julia artifacts when needed.\n\n\"\"\"\nConstructor for retrieving default `RandLinConfig` instances.\n# Arguments\n- `id`: identifier for default parameter set\n# Output\n- `system`: `RandLinConfig` instance\n\"\"\"\nfunction RandLinConfig(id::String)\n    Random.seed!(0)\n\n    if id == \"A\"\n        return RandLinConfig(5, 3)\n    elseif id == \"B\"\n        return RandLinConfig(6, 2)\n    elseif id == \"C\"\n        return RandLinConfig(7, 4)\n    else\n        error(\"Invalid id!\")\n    end\nend\n\n</details>","category":"section"},{"location":"Contribution/#Tests","page":"Contribution","title":"Tests","text":"To guarantee that all merged code is in a working state, automatic test pipelines have been set up for this repository. The test are run through GitHub Actions, using the Julia Test module. \n\nEvery benchmark model has its own /test/<System>Tests.jl file, which is included in /test/runtests.jl. While the goal is to achieve near total code coverage, it is not necessary to 'test everything'. We suggest to at least test the following for a variety of configurations:\n\nSystem matrix sizes,\nSystem transfer functions,\nCorrespondence between 'natural' and port-Hamiltonian system matrices.\n\nTo contribute to the tests, add a file based on the example below at /test/<System>Tests.jl and add a corresponding include statement to /test/runtests.jl.\n\n<details><summary>Test Example</summary><p>\n\n@testset \"RandLin\" begin\n    ids = [\"A\", \"B\", \"C\"]\n\n    for id in ids\n        config = RandLinConfig(id)\n        J, R, G = construct_system(config)\n        sys = PHSystem(config)\n\n        #System matrix sizes\n        @test size(J) == (n_x, n_x)\n        @test size(R) == (n_x, n_x)\n        @test size(G) == (n_x, n_p)\n\n        #Correspondence between \"natural\" and pH form\n        @test sys.E == sparse(1.0I,size(J)...)\n        @test (sys.S, sys.N) .== spzeros(config.n_p, config.n_p)\n        @test (sys.J - sys.R) * sys.Q == J - R\n        @test (sys.G - sys.P) == G\n        @test (sys.G + sys.P)' == G'\n    end\nend\n\n</details>","category":"section"},{"location":"Contribution/#Documentation","page":"Contribution","title":"Documentation","text":"The documentation for this package is built using Documenter.jl. The /docs/make.jl script uses the Markdown files in /docs/src and the images in /docs/src/assets to build a documentation webpage in /docs/build. Equations are rendered using KaTeX, which is invoked in Markdown by the math environment. The webpage can be built and deployed locally by running the commands below in the Julia REPL:\n\nusing LiveServer\ninclude(\"/docs/make.jl\")\nserve(dir=\"/docs/build\")\n\nEach benchmark system is documented in a separate file, containing the following sections:\n\nDescription: mathematical description of the model,\nDerivation: detailed description of the conversion from mathematical model to port-Hamiltonian system,\nInterface: section importing the docstrings from the corresponding <System>.jl file,\nReferences: reference section in BibTeX format.\n\nTo contribute to the documentation, add a file based on the example below at /docs/src/<System>.md and add \"<System>.md\" to the \"Benchmark Systems\" list in /docs/make.jl. Please refer to the current \"Benchmark Systems\" pages for stylistic reference.\n\n<details><summary>Documentation Example</summary><p>\n\n# Random Linear pH-System\n\n## Description\nThis benchmark is a linear port-Hamiltonian system of the form:\n```math\n\\begin{align*}\n    E\\dot{x} &= (J-R)Qx + (G-P)u,\\\\\n    y &= (G+P)^HQx + (S+N)u,\n\\end{align*}\n```\nwhere ``E,Q=I``, ``P,S,N=0`` and ``J,\\ R,\\ G`` are random dense matrices of the correct structure (R positive semi-definite, J, G skew symmetric) with mean 0 and variance 1 [Sabbadini2022](#References).\n\n## Derivation\nThis system is in discrete, port-Hamiltonian form a priori.\n\n## Interface\n```@docs\nRandLinConfig\n```\n```@docs\nRandLinConfig(id::String)\n```\n```@docs\nconstruct_system(config::RandLinConfig)\n```\n\n## References\n```LaTeX\n@article{Sabbadini2022,\n  title = \"On random port-Hamiltonian Systems\",\n  journal = \"We publish anything\"\n}\n```\n\n</details>","category":"section"},{"location":"RclCircuits/#RCL-Ladder-Network-(DAE)","page":"RCL Ladder Network (DAE)","title":"RCL Ladder Network (DAE)","text":"","category":"section"},{"location":"RclCircuits/#Description","page":"RCL Ladder Network (DAE)","title":"Description","text":"This benchmark creates linear, time-invariant pH-DAE models for simple electric circuits consisting of ideal voltage sources, resistors, inductors and capacitors. The modelling of such circuits is described in [4].\n\n(Image: RCL circuit)\n\nModeling of such electric circuits with directed graphs leads to systems of the following form:\n\nbeginaligned\nE dotx(t) = (J-R)x(t) + Gu(t) \ny(t) = G^mathsfT x(t)\nendaligned\n\nwhere\n\nbeginequation*\n\tE = beginbmatrix mathcalA_c C mathcalA_c^mathsfT  0  0  0  L  0  0  0  0 endbmatrix  J = beginbmatrix 0  -mathcalA_l  -mathcalA_v  mathcalA_l^mathsfT  0  0  mathcalA_v^mathsfT  0  0 endbmatrix R = beginbmatrix mathcalA_r R^-1mathcalA_r^mathsfT  0  0  0  0  0  0  0  0 endbmatrix G = beginbmatrix 0  0  -I_m endbmatrix\t\nendequation*\n\nHere, the matrices RLC are positive definite diagonal matrices that contain the resistances, inductances and capacitances, respectively, as entries. The incidence matrices mathcalA_rmathcalA_lmathcalA_cmathcalA_v follow directly from the directed graph of the network and contain only entries in -101. The inputs u(t) of the system are the voltages v_v(t) provided by the voltage sources and the outputs are the negative currents i_v(t) through the voltage sources. The state vector is given by x(t) = beginbmatrix\tv(t)^mathsfT  i_l(t)^mathsfT  i_v(t)^mathsfT endbmatrix^mathsfT with node voltages v(t) and inductor currents i_l(t). Consequently, the dimension of the model is given by n = 3widetilden + 2m, where widetilden denotes the number of loops in the system and m is the number of voltage sources. Since mathcalA_c C mathcalA_c^mathsfT is diagonal for the circuit in Figure 1, a transformation of the model to semi-explicit form is straightforward. The benchmark allows for different configurations of the network that will change the index of the resulting pH-DAE model and its number of inputs and outputs. \n\nSISO/MIMO: In the multiple-input multiple-output (MIMO) version, the inputs are the voltages of both voltage sources and the outputs are the currents as shown in Figure 1. In the single-input single-output (SISO) configuration, we replace the second voltage source by a wire and only consider the input-to-output behaviour from u_1(cdot) to y_1(cdot).\nIndex 1/Index 2: The differentiation index of the system depends on the electrical component that is placed at the position of the red box in Figure 1. A resistor leads to pH-DAEs with index 1 and a capacitor is used in the index 2 case which leads to improper transfer functions.","category":"section"},{"location":"RclCircuits/#Parameters","page":"RCL Ladder Network (DAE)","title":"Parameters","text":"The topology of the network and its characteristics may be changed via\n\nThe values for the resistances r, capacitances c and inductances l. If scalars are provided, the value will be applied to all components of the respective type. Parameters can be supplied to each component separately by providing vectors of suitable length.\nThe number widetilden of loops in the network.\nThe number of inputs (voltage sources) m.","category":"section"},{"location":"RclCircuits/#Interface","page":"RCL Ladder Network (DAE)","title":"Interface","text":"To obtain system matrices E J R and G use the following function call.\n\nusing PortHamiltonianBenchmarkSystems\nE, J, R, Q, G = setup_DAE1_RCL_LadderNetwork_sparse() # for standard parameters\n\nTo specify optional arguments, specify the parameters as named arguments.\n\nusing PortHamiltonianBenchmarkSystems\nE, J, R, Q, G = setup_DAE1_RCL_LadderNetwork_sparse(ns = 500, r = rand(502))\n\nThe transfer function can be defined as follows.\n\nusing LinearAlgebra, PortHamiltonianBenchmarkSystems\nE, J, R, G = setup_DAE1_RCL_LadderNetwork_sparse()\nH(s) = G'*((s*E-(J-R))\\G)","category":"section"},{"location":"RclCircuits/#References","page":"RCL Ladder Network (DAE)","title":"References","text":"R. W. Freund. The SPRIM Algorithm for Structure-Preserving Order Reduction of General RCL Circuits. In: Model Reduction for Circuit Simulation, edited by P. Benner, M. Hinze and E. J. ter Maten (Springer Netherlands, Dordrecht, 2011); pp. 25–52.\n\n\n\n","category":"section"},{"location":"RclCircuits/#PortHamiltonianBenchmarkSystems.setup_DAE1_RCL_LadderNetwork_sparse-Tuple{}","page":"RCL Ladder Network (DAE)","title":"PortHamiltonianBenchmarkSystems.setup_DAE1_RCL_LadderNetwork_sparse","text":"Description:   This demo provides a semi-explicit index-1 port-Hamiltonian DAE system   derived from a simple RCL ladder network with shunt resistor\n\nInput Arguments:\n\nns:           Number of loops in network\nr, c, l:      Resistances, capacitances and inductances vectors with length               ns+2 / ns-1 / ns\nm:            Number of inputs (1: SISO or 2: MIMO)\n\nOutput Arguments:\n\nE, J, R, Q, G:      Index-1 PH-DAE model of the RCL ladder network\n\nReferences:   R. W. Freund. Structure-Preserving Model Order Reduction of               RCL Circuit Equations, 2008.\n\nAuthor: Tim Moser   E-Mail: tim.moser@tum.de   Date:   2021/11/03\n\n\n\n\n\n","category":"method"},{"location":"RclCircuits/#PortHamiltonianBenchmarkSystems.setup_DAE2_RCL_LadderNetwork_sparse-Tuple{}","page":"RCL Ladder Network (DAE)","title":"PortHamiltonianBenchmarkSystems.setup_DAE2_RCL_LadderNetwork_sparse","text":"Index 2 RCL Ladder Network\n\nDescription:   This demo provides a semi-explicit index-2 port-Hamiltonian DAE system   derived from a simple RCL ladder network with buffer capacitor\n\nInput Arguments:\n\nns:           Number of loops in network\nr, c, l:      Resistances, capacitances and inductances vectors with length ns+1 / ns / ns\nm:            Number of inputs (1: SISO or 2: MIMO)\n\nOutput Arguments:\n\nE, J, R, G:      Index-2 PH-DAE model of the RCL ladder network\n\nReferences:   R. W. Freund. Structure-Preserving Model Order Reduction of               RCL Circuit Equations, 2008.\n\nAuthor: Tim Moser   E-Mail: tim.moser@tum.de   Date:   2021/12/14\n\n\n\n\n\n","category":"method"},{"location":"References/#References","page":"References","title":"References","text":"S. Gugercin, R. V. Polyuga, C. Beattie and A. van der Schaft. Structure-Preserving Tangential Interpolation for Model Reduction of Port-Hamiltonian Systems. Automatica 48, 1963–1974 (2012).\n\n\n\nR. Altmann, V. Mehrmann and B. Unger. Port-Hamiltonian Formulations of Poroelastic Network Models. Mathematical and Computer Modelling of Dynamical Systems 27, 429–452 (2021).\n\n\n\nR. V. Polyuga and A. van der Schaft. Structure Preserving Model Reduction of Port-Hamiltonian Systems by Moment Matching at Infinity. Automatica 46, 665–672 (2010).\n\n\n\nR. W. Freund. The SPRIM Algorithm for Structure-Preserving Order Reduction of General RCL Circuits. In: Model Reduction for Circuit Simulation, edited by P. Benner, M. Hinze and E. J. ter Maten (Springer Netherlands, Dordrecht, 2011); pp. 25–52.\n\n\n\nH. Egger, T. Kugler, B. Liljegren-Sailer, N. Marheineke and V. Mehrmann. On Structure-Preserving Model Reduction for Damped Wave Propagation in Transport Networks. SIAM Journal on Scientific Computing 40, A331-A365 (2018).\n\n\n\nA. Brugnoli. A port-Hamiltonian formulation of flexible structures. Modelling and structure-preserving finite element discretization. Ph.D. Thesis, Université de Toulouse, ISAE-SUPAERO, France (2020).\n\n\n\nD. N. Arnold and J. J. Lee. Mixed Methods for Elastodynamics with Weak Symmetry. SIAM Journal on Numerical Analysis 52, 2743–2769 (2014).\n\n\n\nA. Serhani, G. Haine and D. Matignon. Anisotropic Heterogeneous N-D Heat Equation with Boundary Control and Observation: I. Modeling as Port-Hamiltonian System. IFAC-PapersOnLine 52, 51–56 (2019).\n\n\n\nA. Serhani, G. Haine and D. Matignon. Anisotropic Heterogeneous N-D Heat Equation with Boundary Control and Observation: II. Structure-preserving Discretization. IFAC-PapersOnLine 52, 57–62 (2019).\n\n\n\nA. Serhani, D. Matignon and G. Haine. A Partitioned Finite Element Method for the Structure-Preserving Discretization of Damped Infinite-Dimensional Port-Hamiltonian Systems with Boundary Control. In: Geometric Science of Information, Vol. 11712, edited by F. Nielsen and F. Barbaresco (Springer International Publishing, Cham, 2019); pp. 549–558.\n\n\n\nA. Serhani, D. Matignon and G. Haine. Partitioned Finite Element Method for Port-Hamiltonian Systems with Boundary Damping: Anisotropic Heterogeneous 2D Wave Equations. IFAC-PapersOnLine 52, 96–101 (2019).\n\n\n\n","category":"section"},{"location":"DampedWaveNet/#Damped-Wave-Net","page":"Damped Wave Net","title":"Damped Wave Net","text":"","category":"section"},{"location":"DampedWaveNet/#Description","page":"Damped Wave Net","title":"Description","text":"This benchmark is a model for wave propagation in gas pipeline networks, as presented in [5].  The network is modeled as directed, connected graph mathcalG(mathcalVmathcalE), with vertices vinmathcalV, edges einmathcalE and at least one boundary vertex vinmathcalV_bsubseteqmathcalV, connected to a single edge.\n\nOn each edge, the following 1D damped wave equation holds, with presssure p_e (textkgtextm^-1texts^-2), mass flow m_e (textkgtexts^-1) and pipe constants a_e (texts^2), b_e (textm^-2), d_e (textm^-2texts^-1).\n\nbeginalign*\n\ta_epartial_tp_e = -partial_xm_e forall einmathcalE\n\tb_epartial_tm_e = -partial_xp_e-d_em_e forall einmathcalE\nendalign*\n\nAt each inner vertex vinmathcalV_iequivmathcalVsetminusmathcalV_b, the following pressure continuity and mass conservation conditions hold, where p_i_v is the pressure at v and n_e_v is the direction of edge e at v (+1: incoming, -1: outgoing)\n\nbeginalign*\n\tp_e_v equiv p_i_v forall einmathcalE(v) forall vinmathcalV_i\n\tsum_einmathcalE(v) n_e m_e_v = 0 forall vinmathcalV_i\nendalign*\n\nAt each boundary vertex, either a pressure or mass flow must be fixed (p_u_v m_u_v), leaving the other quantity to be solved for (p_y_v m_y_v):\n\nbeginalign*\n\tp_mathcalE(v)_v = p_u_v n_mathcalE(v)m_mathcalE(v)_v = m_y_v forall v inmathcalV_bp\n\tp_mathcalE(v)_v = p_y_v -n_mathcalE(v)m_mathcalE(v)_v = m_u_v forall v inmathcalV_bm\nendalign*","category":"section"},{"location":"DampedWaveNet/#Discretization","page":"Damped Wave Net","title":"Discretization","text":"The Galerkin variational form of the damped wave equations can be formulated as shown below, where p_eintextspan(mathcalP_e) mathcalP_e=pi_1dotspi_n and m_eintextspan(mathcalM_e) mathcalM_e=mu_1dotsmu_n. In our implementation mathcalP_e and mathcalM_e are respectively discontinuous element-wise constant and continuous element-wise linear function spaces, but the shown approach holds in general:\n\nbeginalign*\n\ta_eint_epartial_tp_epi_e mathrmdx = -int_epartial_xm_epi_e mathrmdx forall pi_einmathcalP_e\n\tb_eint_epartial_tm_emu_e mathrmdx = -p_emu_e_partial e + int_ep_epartial_xmu_e mathrmdx -d_eint_em_emu_e mathrmdx forall mu_einmathcalM_e\nendalign*\n\nThe boundary terms -p_emu_e_partial e are the result of integration by parts and can be grouped by vertex as follows:\n\nbeginalign*\n\t-n_e mu_ep_i_v  forall mu_e inmathcalM_equad forall einmathcalE(v)quad forall vinmathcalV_i\n\t-n_mathcalE(v) mu_mathcalE(v)p_u_v forall mu_e inmathcalM_equad forall v inmathcalV_bp\n\t-n_mathcalE(v) mu_mathcalE(v)p_y_v forall mu_e inmathcalM_equad forall v inmathcalV_bm\nendalign*\n\nIt now becomes apparent that in matrix form, the linear operators in several pairs of terms are each other's (negative) transpose. Hence, we can write our system of equations as the following linear DAE:\n\nbeginalign*\n    underbrace\n    beginbmatrix\n        A_pM_p    \n         B_mM_m   \n          0  \n           0\n    endbmatrix_E\n    beginbmatrix\n        dotp\n        dotm\n        dotp_i\n        dotp_y\n    endbmatrix =\n    underbrace\n    beginbmatrix\n         -G_m   \n        G_m^mathsfT -D_mM_m -C_m^mathsfT  U_m^mathsfT\n         C_m  \n         -U_m \n    endbmatrix_A\n    beginbmatrix\n        p\n        m\n        p_i\n        p_y\n    endbmatrix +\n    underbrace\n    beginbmatrix\n        0 \n        Y_m^mathsfT \n         0 \n         I\n    endbmatrix_B\n    beginbmatrix\n        p_u\n        m_u\n    endbmatrix\n    beginbmatrix\n        m_y\n        p_y\n    endbmatrix =\n    underbrace\n    beginbmatrix\n        0  Y_m  \n          0   I\n    endbmatrix_B^mathsfT \n    beginbmatrix\n        p\n        m\n        p_i\n        p_y\n    endbmatrix\nendalign*\n\nM_p M_m: mass matrices for p m\nA_p B_m D_m: diagonal matrices containing the edge parameters a_e b_e d_e\nG_m: Galerkin variational operator for partial_xm\nC_m: mass conservation conditions for m\nU_m Y_m: matrices selecting m_u m_y from m\n\nSince p contains all the pressure variables, p_i and p_y are redundant in the solution vector. However, they are not explicitly tied to p in the system. It can be proven that the system has a unique solution and that this constrains p_i and p_y to be equal to their counterparts in p, ensuring that the original variational problem is solved (cf. [5]).\n\nFinally, the system can be written in linear port-Hamiltonian form as follows:\n\nbeginalign*\n    Edotx = (J-R)Qx + (G-P)u\n    y = (G+P)^mathsfTQx + (S+N)u\nendalign*\n\nwhere J = frac12(A-A^mathsfT), R = -frac12(A+A^mathsfT), Q = I, G = B, P = 0, S = N = 0.","category":"section"},{"location":"DampedWaveNet/#Interface","page":"Damped Wave Net","title":"Interface","text":"","category":"section"},{"location":"DampedWaveNet/#References","page":"Damped Wave Net","title":"References","text":"H. Egger, T. Kugler, B. Liljegren-Sailer, N. Marheineke and V. Mehrmann. On Structure-Preserving Model Reduction for Damped Wave Propagation in Transport Networks. SIAM Journal on Scientific Computing 40, A331-A365 (2018).\n\n\n\n","category":"section"},{"location":"DampedWaveNet/#PortHamiltonianBenchmarkSystems.DampedWaveNetConfig","page":"Damped Wave Net","title":"PortHamiltonianBenchmarkSystems.DampedWaveNetConfig","text":"Composite type descibing pressure wave conducting pipe systems, as described in Egger et al. 'Structure-Preserving Model Reduction for Damped Wave Propagation in Transport Networks'.\n\nArguments\n\nincidence_matrix: Sparse incidence matrix describing the pipe network\nedge_parameters: Named tuple containing vectors a, b, d, l, n, respectively containing the parameters a_e b_e d_e,                    the length and the number of FEM elements for each pipe (ordered as in incidence_matrix)\nboundary_conditions: Vector of chars 'p', 'm', determining the boundary condition type at each boundary                        vertex (ordered as in incidence_matrix)\n\n\n\n\n\n","category":"type"},{"location":"DampedWaveNet/#PortHamiltonianBenchmarkSystems.DampedWaveNetConfig-Tuple{String}","page":"Damped Wave Net","title":"PortHamiltonianBenchmarkSystems.DampedWaveNetConfig","text":"External constructor providing various default instances of DampedWaveNetConfig.\n\nArguments\n\nid: String to identify a default configuration, with possible values: \"pipe\", \"fork\", \"diamond\"\n\n\n\n\n\n","category":"method"},{"location":"DampedWaveNet/#PortHamiltonianBenchmarkSystems.construct_system-Tuple{DampedWaveNetConfig}","page":"Damped Wave Net","title":"PortHamiltonianBenchmarkSystems.construct_system","text":"Method for constructing the \"natural\" DAE system.\n\nArguments\n\nconfig: DampedWaveNetConfig instance\n\nOutput\n\nsystem: Named tuple containing sparse matrices E, A, B\n\n\n\n\n\n","category":"method"},{"location":"LosslessWave/#The-lossless-wave-equation-with-Neumann-boundary-control","page":"The lossless wave equation with Neumann boundary control","title":"The lossless wave equation with Neumann boundary control","text":"","category":"section"},{"location":"LosslessWave/#The-model","page":"The lossless wave equation with Neumann boundary control","title":"The model","text":"We follow [10, 11] for the derivation of the port-Hamiltonian formulation of the lossless wave equation with Neumann boundary control. Let us consider the vertical deflection from equilibrium w of a 2D membrane Omega subset mathbbR^2. Denoting rho the mass density and T the Young modulus of the membrane, a positive definite tensor, leads to the following well-known wave equation\n\nrho(x) fracpartial^2partial t^2 w(tx) - rm div left( T(x) cdot rm grad left( w(tx) right) right) = 0 quad t ge 0  x in Omega\n\ntogether with Neumann boundary control \n\nleft( T(x) cdot rm grad left( w(tx) right) right) cdot mathbfn = u_partial(tx) quad t ge 0  x in partial Omega\n\nwhere mathbfn is the outward normal to Omega.\n\nThe Hamiltonian is the total mechanical energy, given as the sum of potential and kinetic energies\n\nmathcalH(t) = frac12 int_Omega left( rm grad left( w(tx) right) right)^top cdot T(x) cdot rm grad left( w(tx) right) rm dx + frac12 int_Omega rho(x) left( fracpartialpartial t w(tx) right)^2 rm dx qquad t ge 0\n\nTaking the strain and the linear momentum\n\nalpha_q = rm grad left( w right) qquad alpha_p = fracpartialpartial t w\n\nas energy variables, the Hamiltonian rewrites\n\nmathcalH(t) = mathcalH(alpha_q (tcdot) alpha_p(tcdot)) = frac12 int_Omega left( alpha_q(tx) right)^top cdot T(x) cdot alpha_q(tx) rm dx + frac12 int_Omega fracalpha_p^2(tx)rho(x) rm dx\n\nThe co-energy variables are by definition the variational derivatives of the Hamiltonian\n\ne_q = delta_alpha_q mathcalH = T cdot alpha_q \nqquad e_p = delta_alpha_p mathcalH = fracalpha_prho\n\ni.e. the stress and the velocity respectively. These equalities are the constitutive relation which close the system.\n\nThanks to these variables, the wave equation writes as a port-Hamiltonian system\n\nbeginpmatrix\nfracpartialpartial t alpha_q \nfracpartialpartial t alpha_p\nendpmatrix =\nbeginbmatrix\n0  rm grad \nrm div  0\nendbmatrix\nbeginpmatrix\ne_q \ne_p\nendpmatrix \nqquad leftlbrace\nbeginarrayrcl\ne_q = T cdot alpha_q \ne_p = fracalpha_prho\nendarrayright\nqquad leftlbrace\nbeginarrayrcl\nu_partial = e_q cdot mathbfn \ny_partial = e_pmid_partial Omega\nendarrayright\n\nThe power balance satisfied by the Hamiltonian is\n\nfracrm d rm dt mathcalH = langle u_partial y_partial rangle_H^-frac12(partial Omega)H^frac12(partial Omega)\n\nTo get rid of the algebraic constraints induced by the constitutive relations, one rewrites the port-Hamiltonian system as\n\nbeginbmatrix\nT^-1  0 \n0  rho\nendbmatrix\nbeginpmatrix\nfracpartialpartial t e_q \nfracpartialpartial t e_p\nendpmatrix =\nbeginbmatrix\n0  rm grad \nrm div  0\nendbmatrix\nbeginpmatrix\ne_q \ne_p\nendpmatrix \nqquad leftlbrace\nbeginarrayrcl\nu_partial = e_q cdot mathbfn \ny_partial = e_pmid_partial Omega\nendarrayright\n\nknown as the co-energy formulation. This allows to get a simple Ordinary Differential Equation at the discrete level (instead of a Differential Algebraic Equation in general).","category":"section"},{"location":"LosslessWave/#Structure-preserving-discretization","page":"The lossless wave equation with Neumann boundary control","title":"Structure-preserving discretization","text":"","category":"section"},{"location":"LosslessWave/#Weak-formulation","page":"The lossless wave equation with Neumann boundary control","title":"Weak formulation","text":"Let phi_q, varphi_p and psi be vector-valued, scalar-valued and boundary scalar-valued test functions respectively. The weak formulation reads\n\nleftlbrace\nbeginarrayrcl\ndisplaystyle int_Omega phi_q cdot T^-1 cdot fracpartialpartial t e_q \n= displaystyle int_Omega phi_q cdot rm grad left( e_p right) \ndisplaystyle int_Omega varphi_p rho fracpartialpartial t e_p \n= displaystyle int_Omega varphi_p rm div left( e_q right) \ndisplaystyle int_partial Omega psi y_partial = displaystyle int_partial Omega psi e_p\nendarrayright","category":"section"},{"location":"LosslessWave/#Integration-by-parts","page":"The lossless wave equation with Neumann boundary control","title":"Integration by parts","text":"The integration by parts of the second line makes u_partial = e_q cdot mathbfn appear\n\nleftlbrace\nbeginarrayrcl\ndisplaystyle int_Omega phi_q cdot T^-1 cdot fracpartialpartial t e_q \n= displaystyle int_Omega phi_q cdot rm grad left( e_p right) \ndisplaystyle int_Omega varphi_p rho fracpartialpartial t e_p \n= displaystyle - int_Omega rm grad left( varphi_p right) cdot e_q + int_partial Omega varphi_p u_partial \ndisplaystyle int_partial Omega psi y_partial = displaystyle int_partial Omega psi e_p\nendarrayright","category":"section"},{"location":"LosslessWave/#Projection","page":"The lossless wave equation with Neumann boundary control","title":"Projection","text":"Let (phi_q^i)_1 le i le N_q, (varphi_p^j)_1 le j le N_p and (psi^k)_1 le k le N_partial be finite element families for q-type, p-type and boundary-type variables. Variables are approximated in their respective finite element family\n\ne_q^d(tx) = sum_i=1^N_q e_q^i(t) phi_q^i(x)\nqquad e_p^d(tx) = sum_j=1^N_p e_p^j(t) varphi_p^j(x)\n\nu_partial^d(tx) = sum_k=1^N_partial u_partial^k(t) psi^k(x)\nqquad y_partial^d(tx) = sum_k=1^N_partial y_partial^k(t) psi^k(x)\n\nDenoting underlinestar the (time-varying) vector of coordinates of the discretisation star^d of star in its respective finite element family, the discrete system reads\n\nundersetMunderbracebeginbmatrix\nM_q  0  0 \n0  M_p  0 \n0  0  M_partial\nendbmatrix  \nbeginpmatrix\nfracrm d rm dt underlinee_q(t) \nfracrm d rm dt underlinee_p(t) \n - underliney_partial(t)\nendpmatrix =\nundersetJunderbracebeginbmatrix\n0  D  0 \n -D^top  0  B \n0  -B^top  0\nendbmatrix  \nbeginpmatrix\nunderlinee_q(t) \nunderlinee_p(t) \nunderlineu_partial(t)\nendpmatrix\n\nwhere\n\n(M_q)_ij = int_Omega phi_q^i cdot T^-1 cdot phi_q^j\nqquad \n(M_p)_ij = int_Omega varphi_p^i rho varphi_p^j\nqquad \n(M_partial)_ij = int_partial Omega psi^i psi^j\n\nand\n\n(D)_ij = int_Omega phi_q^i cdot rm grad left( varphi_p^j right)\nqquad\n(B)_jk = int_partial Omega varphi_p^j psi^k","category":"section"},{"location":"LosslessWave/#Discrete-Hamiltonian","page":"The lossless wave equation with Neumann boundary control","title":"Discrete Hamiltonian","text":"By definition, the discrete Hamiltonian is equal to the continuous Hamiltonian evaluated in the approximated variables. As we are working with the co-energy formulation, a first step is to restate the Hamiltonian in terms of co-energy variables\n\nmathcalH = frac12 int_Omega e_q cdot T^-1 cdot e_q + frac12 int_Omega rho (e_p)^2\n\nThen, the discrete Hamiltonian is defined as\n\nmathcalH^d = frac12 int_Omega e_q^d cdot T^-1 cdot e_q^d + frac12 int_Omega rho (e_p^d)^2\n\nAfter straightforward computations, it comes\n\nmathcalH^d(t) = frac12 underlinee_q(t)^top M_q underlinee_q(t) + frac12 underlinee_p(t)^top M_p underlinee_p(t)\n\nand the discrete power balance follows\n\nfracrm d rm dt mathcalH^d(t) = underlineu_partial(t)^top M_partial underliney_partial(t)","category":"section"},{"location":"LosslessWave/#Interface","page":"The lossless wave equation with Neumann boundary control","title":"Interface","text":"We have generated models in domains of three different shapes disc, rectangle, and L each for three different resolutions small, medium, and large. The models can be configured via\n\nusing PortHamiltonianBenchmarkSystems\nconfig = LosslessWaveModelConfigFactory(shape=\"disc\", size=\"small\")\n\nand the data is loaded using construct_system(config).","category":"section"},{"location":"LosslessWave/#References","page":"The lossless wave equation with Neumann boundary control","title":"References","text":"A. Serhani, D. Matignon and G. Haine. A Partitioned Finite Element Method for the Structure-Preserving Discretization of Damped Infinite-Dimensional Port-Hamiltonian Systems with Boundary Control. In: Geometric Science of Information, Vol. 11712, edited by F. Nielsen and F. Barbaresco (Springer International Publishing, Cham, 2019); pp. 549–558.\n\n\n\nA. Serhani, D. Matignon and G. Haine. Partitioned Finite Element Method for Port-Hamiltonian Systems with Boundary Damping: Anisotropic Heterogeneous 2D Wave Equations. IFAC-PapersOnLine 52, 96–101 (2019).\n\n\n\n","category":"section"},{"location":"LosslessWave/#PortHamiltonianBenchmarkSystems.LosslessWaveModelConfigFactory","page":"The lossless wave equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.LosslessWaveModelConfigFactory","text":"LosslessWaveModelConfigFactory(; shape::String, size::String)\n\nArguments\n\nshape (String): Shape of the domain. One of \"disc\", \"L\", \"rectangle\".\nsize (String): Size of the domain. One of \"small\", \"medium\", \"large\".\n\n\n\n\n\n","category":"function"},{"location":"LosslessWave/#PortHamiltonianBenchmarkSystems.LosslessWaveModelConfig","page":"The lossless wave equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.LosslessWaveModelConfig","text":"LosslessWaveModelConfig\n\nConfiguration for the lossless wave model benchmark system. Construct with LosslessWaveModelConfigFactory.\n\nArguments\n\nn: System dimension\n\n\n\n\n\n","category":"type"},{"location":"LosslessWave/#PortHamiltonianBenchmarkSystems.construct_system-Tuple{LosslessWaveModelConfig}","page":"The lossless wave equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.construct_system","text":"construct_system(config::LosslessWaveModelConfig)\n\nConstruct the lossless wave model benchmark system.\n\nArguments\n\nconfig: Configuration for the lossless wave model benchmark system from the configuration struct.\n\nOutput:\n\nMatrices M_p, M_q, M_b, B, and D.\n\n\n\n\n\n","category":"method"},{"location":"SingleMSDChain/#Single-MSD-Chain","page":"Single MSD Chain","title":"Single MSD Chain","text":"","category":"section"},{"location":"SingleMSDChain/#Description","page":"Single MSD Chain","title":"Description","text":"This benchmark is a model for a mass-spring-damper chain. It is presented in [1].\n\n(Image: Mass-spring-damper chain system)\n\nThe chain consists of N = fracn2 masses m_1ldotsm_n2 that are each connected with their neighboring masses by springs with spring constants k_1ldotsk_n2. The last mass m_n2 is connected to a wall via the spring k_n2 while at the first two masses m_1 and m_2 external forces u_1(cdot) and u_2(cdot) are applied. Moreover, each mass is connected with the ground with a damper with viscosities c_1ldotsc_n2. This configuration leads to a second-order system of the form\n\nMddotq(t)+Cdotq(t)+Kq(t) = B_2u(t)\n\nwhere q(t) = beginbmatrix q_1(t)ldotsq_n2(t)endbmatrix^mathsfT is the vector of displacements of each mass and u(t) = beginbmatrix u_1(t)u_2(t)endbmatrix^mathsfT is the vector of inputs. Moreover, \n\nbeginaligned\nM = beginbmatrix m_1       m_2       m_3       ddots       m_n2 endbmatrix quad C = beginbmatrix c_1       c_2       c_3       ddots       c_n2 endbmatrix \nK = beginbmatrix k_1  -k_1     -k_1  k_1 + k_2  -k_2     -k_2  k_2+k_3  ddots      ddots  ddots  -k_n2-1     -k_n2-1  k_n2-1 + k_n2 endbmatrix quad B_2 = beginbmatrix 1  0 \n0  1  0  0  vdots  vdots  0  0 endbmatrix\nendaligned\n\nThe output of the system is chosen as the velocities of the masses which are controlled, i.e.,\n\ny(t) = beginbmatrix dotq_1(t)  dotq_2(t)endbmatrix\n\nA linearization leads to the first-order system\n\nbeginaligned\nbeginbmatrix I_n  0  0  M endbmatrix beginbmatrix dotx_1(t)  dotx_2(t) endbmatrix  =\nbeginbmatrix 0  I_n  -K  -D endbmatrix beginbmatrix x_1(t)  x_2(t) endbmatrix + beginbmatrix 0  B_2 endbmatrix u(t) \ny(t) = beginbmatrix 0  B_2^mathsfT endbmatrix beginbmatrix x_1(t)  x_2(t) endbmatrix\nendaligned\n\nwhere x_1(t) = q(t) and x_2(t) = dotq(t). Assume that one uses the momenta instead of velocities, i.e., x_2(t) = dotq(t) is replaced by\n\n  p(t) = beginbmatrix p_1(t)ldotsp_n2(t)endbmatrix^mathsfT = beginbmatrix m_1q_1(t)ldotsm_n2q_n2(t)endbmatrix^mathsfT\n\nWith this and by appropriate permutations of columns and rows of the system equations one finally obtains the port-Hamiltonian formulation\n\nbeginaligned\ndot x(t) = (J-R) Q x(t) + Bu(t) \ny(t) = B^mathsfT Q x(t)\nendaligned\n\nwhere\n\nbeginaligned\n J = beginbmatrix 0  1       -1  0         0  1       -1  0  ddots       ddots  ddots  ddots        ddots  0  1        -1  0 endbmatrix quad \n R = beginbmatrix 0  0       0  c_1         0  0       0  c_2  ddots       ddots  ddots  ddots        ddots  0  0        0  c_n2 endbmatrix \n Q = beginbmatrix k_1  0  k_1  0      0  frac1m_1  0  0      -k_1  0  k_1+k_2  0  -k_2  0    0  0  0  frac1m_2  0  0       ddots  ddots  ddots  ddots       ddots  ddots   ddots  ddots       -k_n2-1  0  k_n2-1+k_n2  0      0  0  0  frac1m_n2 endbmatrix quad B = beginbmatrix 0  0  1  0  0  0  0  1  vdots  vdots  vdots  vdots  0  0  0  0 endbmatrix\nendaligned\n\nand \n\n x(t) = beginbmatrix q_1(t)p_1(t)q_2(t)p_2(t)ldotsq_n2(t)p_n2(t)endbmatrix^mathsfT","category":"section"},{"location":"SingleMSDChain/#Parameters","page":"Single MSD Chain","title":"Parameters","text":"This is a variable-dimension model in which N = fracn2 in N can be determined by the user. We have chosen these default parameters (without units).\n\nbeginaligned\n m_1 = ldots = m_n2 = 4 \n k_1 = ldots = k_n2 = 4 \n c_1 = ldots = c_n2 = 1 \n N = 50\nendaligned","category":"section"},{"location":"SingleMSDChain/#Interface","page":"Single MSD Chain","title":"Interface","text":"The transfer function can be defined as follows.\n\nusing LinearAlgebra, PortHamiltonianBenchmarkSystems\nconfig = SingleMSDConfig()\nJ, R, Q, B = construct_system(config)\nH(s) = B'*Q*((s*I-(J-R)*Q)\\B)\n\nThe parameters can be specified as follows\n\nusing LinearAlgebra, PortHamiltonianBenchmarkSystems\nconfig = SingleMSDConfig(n_cells=50, io_dim = 2, m = 4.0, k = 4.0, c = 1.0)\nJ, R, Q, B = construct_system(config)\nH(s) = B'*Q*((s*I-(J-R)*Q)\\B)","category":"section"},{"location":"SingleMSDChain/#Control-System","page":"Single MSD Chain","title":"Control System","text":"For controller design benchmarks, we have defined a plant model based on the mass-spring-damper chain. It is defined with force control and verlocity outputs on the first two masses. The disturbance input and performance outputs are forces and verlocities, respectively, at the third and fourth mass. The plant is returned in standard state-space format to simplify interoperation with standard controller design methods.","category":"section"},{"location":"SingleMSDChain/#References","page":"Single MSD Chain","title":"References","text":"S. Gugercin, R. V. Polyuga, C. Beattie and A. van der Schaft. Structure-Preserving Tangential Interpolation for Model Reduction of Port-Hamiltonian Systems. Automatica 48, 1963–1974 (2012).\n\n\n\n","category":"section"},{"location":"SingleMSDChain/#PortHamiltonianBenchmarkSystems.SingleMSDConfig","page":"Single MSD Chain","title":"PortHamiltonianBenchmarkSystems.SingleMSDConfig","text":"This struct configures port Hamiltonian mass-spring-damper systems described in S. Gugercin et al.:       Structure-preserving tangential interpolation for model reduction of       port-Hamiltonian systems\n\nArguments\n\nn_cells: The number of masses. The system dimension is 2n_cells\nio_dim: The input and output dimension of the system\nc: The amount of damping\nm: The weight of the masses\nk: The stiffness of the springs\n\nOutputs\n\nconfig: The configuration struct for the system. The system can subsequently be created with construct_system(config)\n\n\n\n\n\n","category":"type"},{"location":"SingleMSDChain/#PortHamiltonianBenchmarkSystems.generate_MSD_plant","page":"Single MSD Chain","title":"PortHamiltonianBenchmarkSystems.generate_MSD_plant","text":"generate_MSD_plant(n_cells::Int)\n\nConstructor for the configuration as control problem.\n\nArguments\n\nn_cells: The number of masses. The system dimension is 2n_cells.\n\nOutputs\n\nA: The system matrix of the plant.\nB: The input matrix of the plant, as a concatenation of B=hcat(B1, B2), where B1 and B2 describe the disturbance input and the control input, respectively. B2 has nw columns.\nC: The output matrix of the plant, as a concatenation of C=vcat(C1, C2), where C1 and C2 describe the performance output and the measured output, respectively. C2 has nz columns.\nD: The feedthrough matrix of the plant, as a concatenation of D=vcat(hcat(D11, D12), hcat(D21, D22)).\ndimension nw: dimension of the disturbance input.\ndimension nz: dimension of the performance output.\n\n\n\n\n\n","category":"function"},{"location":"RCLLadderODE/#RCL-Ladder-Network-(ODE)","page":"RCL Ladder Network (ODE)","title":"RCL Ladder Network (ODE)","text":"","category":"section"},{"location":"RCLLadderODE/#Description","page":"RCL Ladder Network (ODE)","title":"Description","text":"This benchmark considers a linear, time-invariant pH-ODE model for electrical ladder networks as described and used for numerical examples in [1, 3]. \n\n(Image: RCL ladder network system)\n\nThe network consists of N=tfracn2 cells, where each cell i=1ldotsN contains a resistor with resistance R_i, capacitor with capacity C_i, and inductor with inductance L_i. The last cell contains one additional resistor with resistance R_tfracn2+1. \n\nThe input of the system is chosen as the current I and the output is the voltage over the first capacitor U_C_1. The state variables are alternating the charge q_i of the capacitors and the flux phi_i of the inductors, i.e., \n\n\tx(t) = beginbmatrix\n\t\tq_1(t) phi_1(t) ldots q_tfracn2(t) phi_tfracn2(t)\t\t\n\tendbmatrix in R^n\n\nThis choice yields the following pH system matrices\n\n\tbeginaligned\n\tJ = beginbmatrix\n\t\t0  -1  0  0\n\t\t1  ddots  ddots  0\n\t\t0  ddots  ddots  -1\n\t\t0  0  1  0\n\tendbmatrix \n\tR = mathrmdiag(0 R_1 0 R_2 cdots R_tfracn2 + R_tfracn2+1)\n\tQ = mathrmdiag(C_1^-1 L_1^-1 C_2^-1 L_2^-1 cdots C_tfracn2^-1 L_tfracn2^-1)  \n\tG^top = beginbmatrix\n\t\t1 \n\t\tcdots \n\t\t0\n\tendbmatrix\n\tendaligned","category":"section"},{"location":"RCLLadderODE/#Parameters","page":"RCL Ladder Network (ODE)","title":"Parameters","text":"The number of cells N = tfracn2 in N can be chosen by the user and the input dimension can be set to m = 1 2. The remaining parameters R_i, C_i, and L_i can be chosen as positive real numbers. Following [3], the default parameters are\n\nbeginaligned\n    N = 100 \n    m = 1 \n    R_1 = ldots = R_50 = 02 \n    R_51 = 04 \n    C_1 = ldots = C_50 = 1 \n    L_1 = ldots = L_50 = 1 \nendaligned","category":"section"},{"location":"RCLLadderODE/#Interface","page":"RCL Ladder Network (ODE)","title":"Interface","text":"The system matrices can be obtained via the RCLLadderConfig.\n\nIn more detail, the system matrices from [3] can be obtained as follows:\n\nusing PortHamiltonianBenchmarkSystems\nconfig = RCLLadderConfig(\"PS10\")\nJ, R, Q, G = construct_system(config)\n\nAlternatively, the parameters can be specified as follows:\n\nusing PortHamiltonianBenchmarkSystems\nconfig = RCLLadderConfig(2, 2, [1, 2, 3], [4, 5], 6)\nJ, R, Q, G = construct_system(config)\n\nnote: Note\nThe config accepts scalars or vectors for the parameters R, C, and L. If a scalar is provided, it will be applied to all components of the respective type. If a vector is provided, it must have the correct length.","category":"section"},{"location":"RCLLadderODE/#References","page":"RCL Ladder Network (ODE)","title":"References","text":"S. Gugercin, R. V. Polyuga, C. Beattie and A. van der Schaft. Structure-Preserving Tangential Interpolation for Model Reduction of Port-Hamiltonian Systems. Automatica 48, 1963–1974 (2012).\n\n\n\nR. V. Polyuga and A. van der Schaft. Structure Preserving Model Reduction of Port-Hamiltonian Systems by Moment Matching at Infinity. Automatica 46, 665–672 (2010).\n\n\n\n","category":"section"},{"location":"RCLLadderODE/#PortHamiltonianBenchmarkSystems.RCLLadderConfig","page":"RCL Ladder Network (ODE)","title":"PortHamiltonianBenchmarkSystems.RCLLadderConfig","text":"This struct configures port-Hamiltonian ODE RCL ladder network described in [3] and [1].\n\nArguments\n\nn_cells::Int: The number of cells in the ladder network\nio_dim::Int: The input and output dimension of the system\nR::Vector{T}: The resistances (Vector of length n_cells + 1)\nC::Vector{T}: The capacitances (Vector of length n_cells)\nL::Vector{T}: The inductances (Vector of length n_cells)\n\nOutputs\n\nconfig: The configuration struct for the system. The system can subsequently be created with construct_system(config)\n\n\n\n\n\n","category":"type"},{"location":"RCLLadderODE/#PortHamiltonianBenchmarkSystems.RCLLadderConfig-Tuple{String}","page":"RCL Ladder Network (ODE)","title":"PortHamiltonianBenchmarkSystems.RCLLadderConfig","text":"RCLLadderConfig(id::String)\n\nExternal constructor providing various default instances of RCLLadderConfig.\n\nArguments\n\nid: The identifier of the desired configuration. Use \n\"PS10\" for the setup in [3] or \n\"GPBS12\" for the setup in [1].\n\nOutputs\n\nconfig: Instance of RCLLadderConfig.\n\n\n\n\n\n","category":"method"},{"location":"PoroModel/#Poroelastic-Network-Model","page":"Poroelastic Network Model","title":"Poroelastic Network Model","text":"","category":"section"},{"location":"PoroModel/#Description","page":"Poroelastic Network Model","title":"Description","text":"This benchmark is the poroelastic network model presented in [2].  The model is derived from Biot's consolidation model  for poroelastic elasticity. Let Omega subseteq mathbbR^d be a Lipschitz  domain with din23 and mathbbT = 0T for T in (0infty). Consider the system of coupled partial differential equations\n\nbeginaligned\n rho fracpartial^2partial t^2 u(txi) - nabla sigma(u(txi)) + \n nabla (alpha p(txi)) = widehatf(txi) quad textin  (0T times \nOmega  \n fracpartialpartial t left( alpha nablacdot u(txi) + \n frac1M p(txi)right) - nabla cdot left( frackappanunabla \np(txi) right) = widehatg(txi) quad textin  (0T times Omega\nendaligned\n\nHere, the displacement field u mathbbT times Omega to R and the  pressure field p mathbbT times Omega to R are searched solution  functions. Moreover, the stress-strain constitute relation\n\nsigma(u(txi)) = 2muvarepsilon(u(txi)) + \nlambda(nabla cdot u(txi)) mathcalI quad textwith quad \nvarepsilon(u(txi)) = frac12left( nabla u(txi) + (nabla u(txi))^mathsfT \nright)\n\nis satisfied, where\n\nmu and lambda are the Lamé coefficients,\nmathcalI denotes the identity tensor,\nalpha is the Biot-Willes fluid solid coupling coefficient,\nM is the Biot modulus,\nkappa is the permeability,\nrho is the density,\nmu is the fluid viscosity,\nwidehatf (0T times Omega to R^d are the volume-distributed forces,\nwidehatg (0T times Omega to R is the external injection.\n\nThe PDE system is equipped with homogeneous Dirichlet boundary conditions\n\n u(txi) = 0 quad p(txi) = 0 quad texton \n (0T times partial Omega\n\nas well initial conditions p(0cdot) = p^0  partial Omega to R,  u(0cdot) = u^0  partial Omega to R^d, and fracpartialpartial  tu(0cdot) = dotu^0  partial Omega to R^d. Define the Hilbert spaces\n\n mathcalV = leftH_0^1(Omega)right^dquad mathcalH_mathcalV = \nleftL^2(Omega)right^d quad mathcalQ = H_0^1(Omega)quad \nmathcalH_mathcalQ = L^2(Omega)\n\nand the operators\n\nbeginaligned\nmathcalY mathcalH_mathcalV to mathcalH_mathcalV^* quad leftlangle mathcalYuv rightrangle = int_Omega rho u \nvmathrmdxi \nmathcalM mathcalH_mathcalQ to mathcalH_mathcalQ^* \nquad leftlangle mathcalMpq rightrangle = int_Omega frac1M \npqmathrmdxi \nmathcalA mathcalV to mathcalV^* \nquad leftlangle mathcalAuv rightrangle = int_Omega \nsigma(u) varepsilon(v)mathrmdxi \nmathcalK mathcalQ to mathcalQ^* \nquad leftlangle mathcalKpq rightrangle = int_Omega \nfrackappanu nabla p cdot nabla qmathrmdxi \nmathcalD mathcalV to mathcalH_mathcalQ^* \nquad leftlangle mathcalDuq rightrangle = int_Omega alpha(nabla \ncdot u)q mathrmdxi\nendaligned\n\nNote that mathcalY, mathcalM, mathcalA, and mathcalK are  positive definite. To determine the weak form of the PDE, the first equation is  multiplied by a test function v in mathcalV while the second equation is  multiplied with q in mathcalQ. Further we introduce the linear forms\n\n f(t) = int_Omega widehatf(t) cdot mathrmd xi in \nmathcalH_mathcalV^* quad \n g(t) = int_Omega widehatg(t) cdot mathrmd xi in \nmathcalH_mathcalQ^*\n\nThen for initial conditions p^0 in mathcalH_mathcalQ, u^0 in  mathcalV, and dotu^0 in mathcalH_mathcalV and right-hand  sides f in L^2(mathbbTmathcalH_mathcalV) and f in  L^2(mathbbTmathcalH_mathcalQ) one aims to find u in  L^2(mathbbTmathcalV) and p in  L^2(mathbbTmathcalQ) with dotu in  L^2(mathbbTmathcalH_mathcalV), ddotu in  L^2(mathbbTmathcalV^*), and dotp in  L^2(mathbbTmathcalQ^*) such that\n\nbeginaligned\n mathcalY ddotu(t) + mathcalA dotu(t) - mathcalD^* u(t) = f(t) \nquad textin   mathcalV^* \nmathcalD dotu(t) + mathcalM dotp(t) + mathcalK p(t) = g(t) \nquad textin  mathcalQ^*\nendaligned\n\nfor almost all t in (0T), where mathcalD^* denotes the dual operator  of mathcalD. By introducing the auxiliary variable w = dotu, this  operator equation can be written in first-order form as\n\n beginbmatrix\n mathcalY  0  0  0  mathcalA  0  0  0  mathcalM\n endbmatrix beginpmatrix dotw(t)  dotu(t)  dotp(t) \nendpmatrix = \n beginbmatrix\n 0  -mathcalA  mathcalD^*  mathcalA^*  0  0  -mathcalD  0 \n -mathcalK\n endbmatrix beginpmatrix w(t)  u(t)  p(t) endpmatrix + \nbeginpmatrix f(t)  0  g(t) endpmatrix\n\nWriting the inhomogeneity as\n\n beginpmatrix f(t)  0  g(t) endpmatrix = beginbmatrix \noperatornameid  0  0  0  0  operatornameid endbmatrix \nbeginpmatrix f(t)  g(t) endpmatrix\n\nand defining the output\n\n mathbfy(t) = beginpmatrix w(t)  p(t) endpmatrix = beginbmatrix \noperatornameid  0  0  0  0  operatornameid endbmatrix \nbeginpmatrix w(t)  u(t)  p(t) endpmatrix\n\nwe obtain the port-Hamiltonian system\n\nbeginaligned\n mathcalE dotmathbfx(t) = (mathcalJ - mathcalR) mathbfx(t) + \nmathcalB   mathbfv(t) \n mathbfy(t) = mathcalB^* mathbfx(t)\nendaligned\n\nwith \n\n mathcalE = beginbmatrix\n mathcalY  0  0  0  mathcalA  0  0  0  mathcalM\n endbmatrix quad mathcalJ = beginbmatrix\n 0  -mathcalA  mathcalD^*  mathcalA^*  0  0  -mathcalD  0 \n 0\n endbmatrix quad mathcalR = beginbmatrix\n 0  0  0  0  0  0  0  0 \n mathcalK\n endbmatrix quad mathcalB = beginbmatrix \noperatornameid  0  0  0  0  operatornameid endbmatrix\n\nwhere mathbfx(t) = leftbeginsmallmatrix w(t)  u(t)  p(t)  endsmallmatrixright and mathbfv(t) = leftbeginsmallmatrix f(t)   g(t) endsmallmatrixright. \n\nDiscretizing this system with standard mathcalP_1 Lagrange finite elements  results in the finite-dimensional port-Hamiltonian system \n\nbeginaligned\n E dotx(t) = (J - R) x(t) + Bv(t) \n         y(t) = B^mathsfT x(t)\nendaligned\n\nwith \n\nbeginaligned\n E = beginbmatrix\n rho M_u  0  0  0  K_u(mulambda)  0  0  0  frac1M M_p\n endbmatrix quad J = beginbmatrix\n 0  -K_u(mulambda)  alpha D^mathsfT  K_u(mulambda)^mathsfT  0  0  \n-alpha D  0  0\n endbmatrix  R = beginbmatrix\n 0  0  0  0  0  0  0  0 \n frackappanu K_p\n endbmatrix quad mathcalB = beginbmatrix B_f  0  0  0  0  \nB_g endbmatrix\nendaligned","category":"section"},{"location":"PoroModel/#Parameters","page":"Poroelastic Network Model","title":"Parameters","text":"For this benchmark, the domain Omega = 01^2 with d=2 has been chosen  and the volume-distributed forces widehatf and injection widehatg are  spatially independent resulting in two inputs, i.\\,e., B in R^n times m  with m = 2. Moreover, different discretization levels are available,   resulting in systems with state-space dimensions n=320, n = 980, and n =  1805. These discretizations have been obtained using the python  interface of FEniCS. The following fixed parameters have been chosen:\n\nlambda = 12,\nmu = 6.\n\nThe following parameters are variable with the default values\n\nrho = 10^-3,\nalpha = 079,\nfrac1M = 780cdot 10^3,\nfrackappanu = 63333.","category":"section"},{"location":"PoroModel/#Interface","page":"Poroelastic Network Model","title":"Interface","text":"The system matrices E J R and B can be generated by the following function call.\n\nusing PortHamiltonianBenchmarkSystems\nE, J, R, B = poro_elasticity_model()\n\nThe free parameters are given as named arguments. Note that n in  320 980 1805 .\n\nusing PortHamiltonianBenchmarkSystems\nE, J, R, B = poro_elasticity_model(n = 320, eta = 1e-3)\nH(s) = B'*((s*E-(J-R))\\B)\n\nHere H is the transfer function.","category":"section"},{"location":"PoroModel/#References","page":"Poroelastic Network Model","title":"References","text":"R. Altmann, V. Mehrmann and B. Unger. Port-Hamiltonian Formulations of Poroelastic Network Models. Mathematical and Computer Modelling of Dynamical Systems 27, 429–452 (2021).\n\n\n\n","category":"section"},{"location":"PoroModel/#PortHamiltonianBenchmarkSystems.poro_elasticity_model","page":"Poroelastic Network Model","title":"PortHamiltonianBenchmarkSystems.poro_elasticity_model","text":"poro_elasticity_model(; n = 980, rho = 1e-3, alpha = 0.79, M = 1/7.80e3, kappanu = 633.33, eta = 1e-4)\n\nThis function returns a port-Hamiltonian model of linear poroelasticity in a bounded Lipschitz domain as described in     Altmann, Mehrmann, Unger: Port-Hamiltonian Formulations of Poroelastic     Network Models\n\nArguments\n\nn: System dimension (can only be either: 320, 980, or 1805). Default = 980.\nrho: density. Default = 1e-3.\nalpha: Biot-Willis fluid-solid coupling coefficient. Default = 0.79.\nbm: Biot-Modulus. Default = 1/7.8e3.\nkappanu: Quotient kappa/Nu, where kappa denotes the permeability and nu denotes the fluid viscosity. Default = 633.33.\neta: artificial damping coefficient. Default = 1e-4.\n\nOutputs\n\nE J R B, matrices to construct the transfer function H(s) = B^mathsfT(sE-(J-R))^-1B)\n\n\n\n\n\n","category":"function"},{"location":"PoroModel/#PortHamiltonianBenchmarkSystems.PoroElasticityConfig","page":"Poroelastic Network Model","title":"PortHamiltonianBenchmarkSystems.PoroElasticityConfig","text":"This struct configures port Hamiltonian poroelasticity systems described in     Altmann, Mehrmann, Unger: Port-Hamiltonian Formulations of Poroelastic     Network Models\n\nArguments\n\nn: System dimension (can only be either: 320, 980, or 1805). Default = 980.\nrho: density. Default = 1e-3.\nalpha: Biot-Willis fluid-solid coupling coefficient. Default = 0.79.\nbm: Biot-Modulus. Default = 1/7.8e3.\nkappanu: Quotient kappa/Nu, where kappa denotes the permeability and nu denotes the fluid viscosity. Default = 633.33.\neta: artificial damping coefficient. Default = 1e-4.\n\n\n\n\n\n","category":"type"},{"location":"HeatModel/#Heat-equation-with-Neumann-boundary-control","page":"Heat equation with Neumann boundary control","title":"Heat equation with Neumann boundary control","text":"","category":"section"},{"location":"HeatModel/#Description","page":"Heat equation with Neumann boundary control","title":"Description","text":"This example considers the temperature T of a 2D domain Omega subset mathbbR^2.  We follow [8] for the derivation of the port-Hamiltonian formulation and [9] for the subsequent structure-preserving discretization.   Denoting C_v the heat capacity (at constant volume), rho the mass density and lambda the heat conductivity, a positive definite tensor, leads to the following well-known heat equation\n\nrho(x) C_v(x) fracpartialpartial t T(tx) - rm div left( lambda(x) cdot rm grad left( T(tx) right) right) = 0 quad t ge 0  x in Omega\n\ntogether with Neumann boundary control \n\n - left( lambda(x) cdot rm grad left( T(tx) right) right) cdot mathbfn = u_partial(tx) quad t ge 0  x in partial Omega\n\nwhere mathbfn is the outward normal to Omega.\n\nThe Hamiltonian is taken as the usual L^2 functional, despite its lack of thermodynamical meaning\n\nmathcalH(t) = frac12 int_Omega rho(x) C_v(x) left( T(tx) right)^2 rm dx qquad t ge 0\n\nTaking the internal energy density alpha_u = u = C_v T as energy variable (with Dulong-Petit model), the Hamiltonian rewrites\n\nmathcalH(t) = mathcalH(alpha_u(tcdot)) = frac12 int_Omega rho(x) fracalpha_u^2(tx)C_v(x) rm dx\n\nThe co-energy variable is the variational derivatives of the Hamiltonian, with respect to the weighted L^2-product with weight rho\n\ne_u = delta^rho_alpha_u mathcalH = fracalpha_uC_v = T\n\ni.e. the temperature. This equality is the first constitutive relation.\n\nDenoting J_Q the heat flux, the first principle of thermodynamics reads: fracpartialpartial t rho u + rm div left( J_Q right) = 0. Fourier's law gives the second constitutive relation: J_Q = - lambda cdot rm grad left( T right). Then one can write\n\nbeginbmatrix\nrho fracpartialpartial t alpha_u \nf_Q\nendbmatrix =\nbeginbmatrix\n0  -rm div \n  0\nendbmatrix\nbeginbmatrix\ne_u \nJ_Q\nendbmatrix \nqquad leftlbrace\nbeginarrayrcl\ne_u = fracalpha_uC_v \nJ_Q = -lambda cdot rm grad left( T right)\nendarrayright\nqquad leftlbrace\nbeginarrayrcl\nu_partial = J_Q cdot mathbfn \ny_partial = e_umid_partial Omega\nendarrayright\n\nAs port-Hamiltonian systems deal with formally skew-symmetric operator, the example of the wave equation leads us to complete this system with -rm grad in order to obtain the heat equation as a port-Hamiltonian system\n\nbeginbmatrix\nrho fracpartialpartial t alpha_u \nf_Q\nendbmatrix =\nbeginbmatrix\n0  -rm div \n-rm grad  0\nendbmatrix\nbeginbmatrix\ne_u \nJ_Q\nendbmatrix \nqquad leftlbrace\nbeginarrayrcl\ne_u = fracalpha_uC_v \nJ_Q = lambda cdot f_Q\nendarrayright\nqquad leftlbrace\nbeginarrayrcl\nu_partial = J_Q cdot mathbfn \ny_partial = e_umid_partial Omega\nendarrayright\n\nThe power balance satisfied by the Hamiltonian is\n\nfracrm d rm dt mathcalH = - int_Omega J_Q cdot lambda^-1 cdot J_Q + langle u_partial y_partial rangle_H^-frac12(partial Omega)H^frac12(partial Omega)\n\nTo get rid of the first algebraic constraint induced by the constitutive relation e_u = fracalpha_uC_v, one rewrites rho C_v fracpartialpartial t T. Furthermore, we also include Fourier's law as lambda^-1 cdot J_Q = f_Q inside the Dirac structure. The port-Hamiltonian system then reads\n\nbeginbmatrix\nrho C_v fracpartialpartial t T \nlambda^-1 cdot J_Q\nendbmatrix =\nbeginbmatrix\n0  -rm div \n-rm grad  0\nendbmatrix\nbeginbmatrix\nT \nJ_Q\nendbmatrix\nqquad leftlbrace\nbeginarrayrcl\nu_partial = J_Q cdot mathbfn \ny_partial = e_umid_partial Omega\nendarrayright","category":"section"},{"location":"HeatModel/#The-Partitioned-Finite-Element-Method","page":"Heat equation with Neumann boundary control","title":"The Partitioned Finite Element Method","text":"","category":"section"},{"location":"HeatModel/#Weak-formulation","page":"Heat equation with Neumann boundary control","title":"Weak formulation","text":"Let varphi_T, phi_Q and psi be scalar-valued, vector-valued and boundary scalar-valued test functions respectively. The weak formulation reads\n\nleftlbrace\nbeginarrayrcl\ndisplaystyle int_Omega varphi_T rho C_v fracpartialpartial t T \n= displaystyle - int_Omega varphi_T rm div left( J_Q right) \ndisplaystyle int_Omega phi_Q cdot lambda^-1 cdot J_Q \n= displaystyle - int_Omega phi_Q cdot rm grad left( T right) \ndisplaystyle int_partial Omega psi y_partial = displaystyle int_partial Omega psi T\nendarrayright","category":"section"},{"location":"HeatModel/#Integration-by-parts","page":"Heat equation with Neumann boundary control","title":"Integration by parts","text":"The integration by parts of the first line makes u_partial = mathbfJ_Q cdot mathbfn appear\n\nleftlbrace\nbeginarrayrcl\ndisplaystyle int_Omega varphi_T rho C_v fracpartialpartial t T \n= displaystyle int_Omega rm grad left( varphi_T right) J_Q \n-int_partial Omega u_partial varphi_T \ndisplaystyle int_Omega phi_Q cdot lambda^-1 cdot J_Q \n= displaystyle - int_Omega phi_Q cdot rm grad left( T right) \ndisplaystyle int_partial Omega psi y_partial = displaystyle int_partial Omega psi T\nendarrayright","category":"section"},{"location":"HeatModel/#Projection","page":"Heat equation with Neumann boundary control","title":"Projection","text":"Let (varphi_T^i)_1 le i le N_T, (phi_Q^j)_1 le j le N_Q and (psi^k)_1 le k le N_partial be finite element families for u-type, Q-type and boundary-type variables. Variables are approximated in their respective finite element family\n\nT^d(tx) = sum_i=1^N_T T^i(t) varphi_T^i(x)\nqquad J_Q^d(tx) = sum_j=1^N_Q J_Q^j(t) phi_Q^j(x)\n\nu_partial^d(tx) = sum_k=1^N_partial u_partial^k(t) psi^k(x)\nqquad y_partial^d(tx) = sum_k=1^N_partial y_partial^k(t) psi^k(x)\n\nDenoting underlinestar the (time-varying) vector of coordinates of star^d in its respective finite element family, the discrete system reads\n\nundersetMunderbracebeginbmatrix\nM_T  0  0 \n0  M_Q  0 \n0  0  M_partial\nendbmatrix  \nbeginbmatrix\nfracrm d rm dt underlineT(t) \nunderlineJ_Q(t) \n-underliney_partial(t)\nendbmatrix =\nundersetJunderbracebeginbmatrix\n0  D  B \n-D^top  0  0 \n-B^top  0  0\nendbmatrix  \nbeginbmatrix\nunderlineT(t) \nunderlineJ_Q(t) \nunderlineu_partial(t)\nendbmatrix\n\nwhere\n\n(M_T)_ij = int_Omega varphi_T^i rho C_v varphi_T^j\nqquad \n(M_Q)_ij = int_Omega phi_Q^i cdot lambda^-1 cdot phi_Q^j\nqquad \n(M_partial)_ij = int_partial Omega psi^i psi^j\n\nand\n\n(D)_ij = int_Omega rm grad left( varphi_T^i right) cdot phi_Q^j\nqquad\n(B)_jk = int_partial Omega varphi_T^j psi^k","category":"section"},{"location":"HeatModel/#Discrete-Hamiltonian","page":"Heat equation with Neumann boundary control","title":"Discrete Hamiltonian","text":"By definition, the discrete Hamiltonian is equal to the continuous Hamiltonian evaluated in the approximated variables. Recalling that\n\nmathcalH = frac12 int_Omega rho C_v (T)^2\n\nThen, the discrete Hamiltonian is defined as\n\nmathcalH^d = frac12 int_Omega rho C_v (T^d)^2\n\nAfter straightforward computations, it comes\n\nmathcalH^d(t) = frac12 underlineT(t)^top M_T underlineT(t)\n\nand the discrete power balance follows\n\nfracrm d rm dt mathcalH^d(t) = - underlineJ_Q(t)^top M_Q underlineJ_Q(t) + underlineu_partial(t)^top M_partial underliney_partial(t)","category":"section"},{"location":"HeatModel/#Interface","page":"Heat equation with Neumann boundary control","title":"Interface","text":"We have generated models in domains of three different shapes disc, rectangle, and L each for three different resolutions small, medium, and large. The models can be configured via\n\nusing PortHamiltonianBenchmarkSystems\nconfig = HeatModelConfigFactory(shape=\"disc\", size=\"small\")\n\nand the data is loaded using construct_system(config).","category":"section"},{"location":"HeatModel/#References","page":"Heat equation with Neumann boundary control","title":"References","text":"A. Serhani, G. Haine and D. Matignon. Anisotropic Heterogeneous N-D Heat Equation with Boundary Control and Observation: I. Modeling as Port-Hamiltonian System. IFAC-PapersOnLine 52, 51–56 (2019).\n\n\n\nA. Serhani, G. Haine and D. Matignon. Anisotropic Heterogeneous N-D Heat Equation with Boundary Control and Observation: II. Structure-preserving Discretization. IFAC-PapersOnLine 52, 57–62 (2019).\n\n\n\n","category":"section"},{"location":"HeatModel/#PortHamiltonianBenchmarkSystems.HeatModelConfigFactory","page":"Heat equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.HeatModelConfigFactory","text":"HeatModelConfigFactory(; shape::String, size::String)\n\nArguments\n\nshape (String): Shape of the domain. One of \"disc\", \"L\", \"rectangle\".\nsize (String): Size of the domain. One of \"small\", \"medium\", \"large\".\n\n\n\n\n\n","category":"function"},{"location":"HeatModel/#PortHamiltonianBenchmarkSystems.HeatModelConfig","page":"Heat equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.HeatModelConfig","text":"HeatModelConfig\n\nConfiguration for the heat model benchmark system. Construct with HeatModelConfigFactory.\n\nArguments\n\nn: System dimension\n\n\n\n\n\n","category":"type"},{"location":"HeatModel/#PortHamiltonianBenchmarkSystems.construct_system-Tuple{HeatModelConfig}","page":"Heat equation with Neumann boundary control","title":"PortHamiltonianBenchmarkSystems.construct_system","text":"construct_system(config::HeatModelConfig)\n\nConstruct the heat model benchmark system from the configuration struct.\n\nArguments\n\nconfig: Configuration for the lossless wave model benchmark system.\n\nOutput:\n\nMatrices M_T, M_Q, M_b, D, and J.\n\n\n\n\n\n","category":"method"},{"location":"#PortHamiltonianBenchmarkSystems","page":"Home","title":"PortHamiltonianBenchmarkSystems","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"PortHamiltonianBenchmarkSystems is a collection of port-Hamiltonian systems, that can be used as benchmarks for simulation, control, and model-order reduction algorithms. We feature constructors for a wide range of linear, nonlinear, ODE, and DAE systems, as well as several default parameter sets for each.\n\nnote: Note\nThis package is currently developed in Julia. If you want to take advantage of this benchmark collection in other programming languages, you can:Generate any desired system in Julia and save the matrices in a format of your choosing (see JuliaIO),\nGenerate MAT-files for any default parameter set, using our Command-Line Interface.","category":"section"},{"location":"#Installation-and-Usage","page":"Home","title":"Installation and Usage","text":"Install with the Julia package manager Pkg:\n\npkg> add PortHamiltonianBenchmarkSystems # Press ']' to enter the Pkg REPL mode.\n\nor in the Julia REPL:\n\njulia> using Pkg; Pkg.add(\"PortHamiltonianBenchmarkSystems\")\n\nTo generate one of the systems, e.g. a mass-spring-damper chain with the parameters from [1], type:\n\nusing PortHamiltonianBenchmarkSystems\nconfig = SingleMSDConfig(\"Gugercin\")\nJ, R, Q, B = construct_system(config)\n\nNaturally, we may also specify the parameters ourselves:\n\nconfig = SingleMSDConfig(n_cells=10, io_dim=2, c=1.0, m=4.0, k=5.0)\n\nIf you need the system matrices in standard port-Hamiltonian form, type:\n\nsystem = PHSystem(config)\nE, J, R, Q, G, P, S, N = @unpack system\n\nDocstrings for the types and methods shown above can be accessed in the Julia REPL by typing ? and then name of the type or method.","category":"section"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"This benchmark collection is driven by the active support of the port-Hamiltonian community. If your research has lead to port-Hamiltonian models that may be relevant for this collection, we would be happy to include them. If you wish to contribute to the project directly, please consult our Contribution page, fork our Git repository and issue a pull request. Alternatively, feel free to contact us via e-mail to discuss our potential collaboration. We are happy to receive reference implementations in other languages and reimplement them in Julia for this package.","category":"section"}]
}
